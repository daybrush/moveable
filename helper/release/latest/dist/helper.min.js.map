{"version":3,"file":"helper.min.js","sources":["../src/groups.ts","../src/GroupManager.ts"],"sourcesContent":["import { isArray, deepFlat, find } from \"@daybrush/utils\";\nimport { GroupChild, TargetGroupsObject, TargetGroupsType } from \"./types\";\n\nexport class Child {\n    public type: \"group\" | \"root\" | \"single\" = \"single\";\n    public depth = 0;\n    protected _scope: string[] = [];\n    constructor(public parent?: GroupArrayChild) {\n        if (parent) {\n            this.depth = parent.depth + 1;\n        }\n    }\n\n    public get scope(): string[] {\n        const parent = this.parent;\n\n        if (!parent || parent.type === \"root\") {\n            return [];\n        }\n        return [...parent.scope, parent.id];\n    }\n}\n\nexport class GroupSingleChild extends Child {\n    public type = \"single\" as const;\n    constructor(parent: GroupArrayChild, public value: HTMLElement | SVGElement) {\n        super(parent);\n    }\n}\n\n\nexport class GroupArrayChild extends Child {\n    public type: \"group\" | \"root\" = \"group\";\n    public value: GroupChild[] = [];\n    public id = \"\";\n    public map: Map<HTMLElement | SVGElement, GroupSingleChild> = new Map();\n\n    public compare(groups: TargetGroupsType, checker: -1 | 0 | 1 = 0) {\n        const elements = deepFlat(groups);\n        const map = this.map;\n        const elementsLength = elements.length;\n        const mapSize = map.size;\n        const sizeDiff = mapSize - elementsLength;\n\n        // 1 this > groups\n        // 0 this = groups\n        // -1 this < groups\n        const count = elements.filter(element => map.has(element)).length;\n\n        if ((checker > 0 && sizeDiff >= 0) || (checker === 0 && sizeDiff === 0)) {\n            return elementsLength === count;\n        } else if (checker < 0 && sizeDiff <= 0) {\n            return mapSize === count;\n        }\n        return false;\n    }\n    public has(target: HTMLElement | SVGElement) {\n        return this.map.has(target);\n    }\n    public contains(element: HTMLElement | SVGElement): boolean {\n        if (this.has(element)) {\n            return true;\n        }\n        return this.value.some(child => {\n            if (child.type === \"group\") {\n                return child.contains(element);\n            } else {\n                return false;\n            }\n        });\n    }\n    public findContainedChild(element: HTMLElement | SVGElement) {\n        return find(this.value, child => {\n            if (child.type === \"single\") {\n                return child.value === element;\n            } else {\n                return child.contains(element);\n            }\n        });\n    }\n    /**\n     * Exact group containing targets\n     */\n    public findExactChild(target: TargetGroupsType[0]): GroupChild | undefined {\n        const map = this.map;\n\n        if (!isArray(target)) {\n            return map.get(target);\n        }\n        const flatted = deepFlat(target);\n        const length = flatted.length;\n        const single = map.get(flatted[0]);\n\n        if (!single) {\n            return;\n        }\n\n        let parent: GroupArrayChild | undefined = single.parent;\n\n        while (parent) {\n            if (parent.map.size >= length) {\n                return parent;\n            }\n            parent = parent.parent;\n        }\n        return;\n    }\n    public findCommonParent(targets: TargetGroupsType): GroupArrayChild {\n        let depth = Infinity;\n        let childs = targets.map(target => this.findExactChild(target));\n\n        childs.forEach(child => {\n            if (!child) {\n                return;\n            }\n            depth = Math.min(child.depth, depth);\n        });\n\n        while (depth) {\n            --depth;\n            childs = childs.map(child => {\n                let parent: GroupChild | undefined = child;\n\n                while (parent && parent.depth !== depth) {\n                    parent = parent.parent;\n                }\n\n                return parent;\n            });\n            const firstChild = childs.find(child => child);\n\n            if (!firstChild) {\n                return this;\n            }\n            if (childs.every(child => !child || child === firstChild)) {\n                break;\n            }\n        }\n        const commonParent = childs.find(child => child) as GroupArrayChild;\n\n        return commonParent || this;\n    }\n    public findNextChild(\n        target: HTMLElement | SVGElement,\n        range: TargetGroupsType = this.toTargetGroups(),\n        isExact = true,\n    ): GroupArrayChild | null {\n        let nextChild: GroupArrayChild | null = null;\n\n        const length = range.length;\n\n        range.some(child => {\n            if (!isExact && length === 1 && isArray(child)) {\n                nextChild = this.findNextChild(target, child);\n                return nextChild;\n            }\n\n\n            const nextGroupChild = this.findExactChild(child);\n\n            if (!nextGroupChild) {\n                return;\n            }\n\n            if (\"map\" in nextGroupChild) {\n                if (nextGroupChild.map.has(target)) {\n                    nextChild = nextGroupChild;\n                    return true;\n                }\n            }\n        });\n\n        return nextChild;\n    }\n    public findNextExactChild(\n        target: HTMLElement | SVGElement,\n        selected: Array<HTMLElement | SVGElement>,\n        range: TargetGroupsType = this.toTargetGroups(),\n    ): GroupArrayChild | null {\n        // [[1, 2]] => group([1, 2]) exact\n        // [[[1, 2], 3]] => group([1, 2])\n        const nextChild = this.findNextChild(target, range, true);\n\n        if (!nextChild) {\n            return null;\n        }\n\n        if (nextChild.compare(selected, -1)) {\n            return nextChild;\n        }\n        return null;\n    }\n    /**\n     * Finds a group that does not overlap within the range and includes the target.\n     */\n    public findPureChild(\n        target: HTMLElement | SVGElement,\n        range: Array<HTMLElement | SVGElement>,\n    ): GroupArrayChild | null {\n        let nextGroupChild: GroupArrayChild | null = null;\n\n        const childSelected = range.filter(element => this.has(element));\n\n        if (!childSelected.length) {\n            return this;\n        }\n\n        this.value.some(nextChild => {\n            if (nextChild.type !== \"single\" && nextChild.has(target)) {\n                nextGroupChild = nextChild.findPureChild(target, childSelected);\n\n                if (nextGroupChild) {\n                    return true;\n                }\n            }\n        });\n\n        return nextGroupChild;\n    }\n    public findNextPureChild(\n        target: HTMLElement | SVGElement,\n        range: Array<HTMLElement | SVGElement>,\n    ): GroupArrayChild | null {\n        const nextChild = this.findNextChild(target);\n\n        if (nextChild) {\n            return nextChild.findPureChild(target, range);\n        }\n        return null;\n    }\n    public toTargetGroups(): TargetGroupsType {\n        return this.value.map(child => {\n            if (child.type === \"single\") {\n                return child.value;\n            } else {\n                return child.toTargetGroups();\n            }\n        });\n    }\n    public findArrayChild(targets: TargetGroupsType): GroupArrayChild | null {\n        const {\n            value,\n        } = this;\n\n        let result = false;\n\n        if (this.type !== \"root\") {\n            result = value.every(child => {\n                if (child.type === \"single\")  {\n                    return targets.some(target => child.value === target);\n                } else {\n                    return targets.some(target => {\n                        return isArray(target) && child.findArrayChild(target);\n                    });\n                }\n            });\n            // result = targets.every(target => {\n            //     if (isArray(target)) {\n            //         return value.some(child => {\n            //             return child.type === \"group\" && child.findArrayChild(target);\n            //         });\n            //     } else {\n            //         return map.get(target);\n            //     }\n            // });\n        }\n\n        if (result && targets.length === value.length) {\n            return this;\n        } else {\n            let childResult: GroupArrayChild | null = null;\n\n            value.some(child => {\n                if (child.type === \"group\") {\n                    childResult = child.findArrayChild(targets);\n\n                    return childResult;\n                }\n            });\n\n            return childResult;\n        }\n    }\n    public groupByPerfect(selected: Array<HTMLElement | SVGElement>) {\n        return this.value.filter(child => {\n            if (child.type !== \"single\") {\n                return child.compare(selected, -1);\n            }\n            return selected.indexOf(child.value) > -1;\n        });\n    }\n    public add(targets: TargetGroupsObject) {\n        const {\n            value,\n            map,\n        } = this;\n        const depth = this.depth;\n\n        targets.forEach(child => {\n            if (\"groupId\" in child) {\n                const group = new GroupArrayChild(this);\n\n                group.id = child.groupId;\n                group.depth = depth + 1;\n                value.push(group);\n\n                group.add(child.children);\n            } else if (isArray(child)) {\n                const group = new GroupArrayChild(this);\n\n                group.depth = depth + 1;\n                value.push(group);\n\n                group.add(child);\n            } else {\n                const element = \"current\" in child ? child.current : child;\n                const single = new GroupSingleChild(this, element!);\n\n                single.depth = depth + 1;\n                value.push(single);\n                map.set(element!, single);\n            }\n        });\n\n        value.forEach(child => {\n            if (child.type === \"single\") {\n                map.set(child.value, child);\n            } else {\n                child.map.forEach((nextChild, element) => {\n                    map.set(element, nextChild);\n                });\n            }\n        });\n        return parent;\n    }\n}\n","/* eslint-disable no-cond-assign */\nimport { deepFlat, isArray } from \"@daybrush/utils\";\nimport { GroupArrayChild, GroupSingleChild } from \"./groups\";\nimport { GroupChild, TargetGroupsObject, TargetGroupsType, TargetList } from \"./types\";\n\n\nexport function toTargetList(raw: GroupChild[]): TargetList {\n    function targets(childs: GroupChild[] = []) {\n        const arr: TargetGroupsType = [];\n\n        childs.forEach((child) => {\n            if (child.type === \"single\") {\n                arr.push(child.value);\n            } else {\n                arr.push(targets(child.value));\n            }\n        });\n\n        return arr;\n    }\n\n    return {\n        raw: () => raw,\n        targets() {\n            return targets(this.raw());\n        },\n        flatten() {\n            return deepFlat(this.targets());\n        },\n    };\n}\n\nexport class GroupManager extends GroupArrayChild {\n    public type = \"root\" as const;\n    private _targets:  Array<HTMLElement | SVGElement> = [];\n\n    constructor(\n        targetGroups: TargetGroupsType,\n        targets?: Array<HTMLElement | SVGElement>,\n    ) {\n        super();\n        this.set(targetGroups, targets);\n    }\n    public set(\n        targetGroups: TargetGroupsObject,\n        targets: Array<HTMLElement | SVGElement> = [],\n    ) {\n        this.map = new Map();\n        this.value = [];\n\n        const map = this.map;\n        const value = this.value;\n\n        this.add(targetGroups);\n        targets.forEach(target => {\n            if (map.has(target)) {\n                return;\n            }\n            const single = new GroupSingleChild(this, target);\n\n            single.depth = 1;\n            value.push(single);\n            map.set(target, single);\n        });\n        this._targets = targets;\n    }\n    public selectSubChilds(targets: TargetGroupsType, target: HTMLElement | SVGElement) {\n        const root = this;\n        const nextChild = root.findNextChild(target, targets, false);\n        const targetChild = root.map.get(target);\n\n        let nextChilds: GroupChild[] = [];\n\n        if (nextChild) {\n            nextChilds = [nextChild];\n        } else if (targetChild) {\n            nextChilds = [targetChild];\n        } else {\n            nextChilds = [];\n        }\n\n        return toTargetList(nextChilds);\n    }\n    public selectSingleChilds(\n        targets: TargetGroupsType,\n        added: Array<HTMLElement | SVGElement>,\n        removed: Array<HTMLElement | SVGElement>,\n    ) {\n        const nextTargets = [...targets];\n\n        // group can't be added, removed.\n        removed.forEach(element => {\n            const index = nextTargets.indexOf(element);\n\n            if (index > -1) {\n                nextTargets.splice(index, 1);\n            }\n        });\n\n        // Targets can be added one by one\n        added.forEach(element => {\n            nextTargets.push(element);\n        });\n\n        return toTargetList(this.toChilds(nextTargets));\n    }\n    public selectCompletedChilds(\n        targets: TargetGroupsType,\n        added: Array<HTMLElement | SVGElement>,\n        removed: Array<HTMLElement | SVGElement>,\n        continueSelect?: boolean,\n    ) {\n\n        const nextTargets = [...targets];\n        const startSelected = deepFlat(nextTargets);\n\n        // group can be added, removed.\n        removed.forEach(element => {\n            // Single Target\n            const index = nextTargets.indexOf(element);\n\n            if (index > -1) {\n                // single target or group\n                nextTargets.splice(index, 1);\n                return;\n            }\n            // Group Target\n            const removedChild = continueSelect\n                // Finds the nearest child for element and nextTargets.\n                ? this.findNextChild(element, nextTargets)\n                // Find the nearest exact child for element, all removed and nextTargets.\n                : this.findNextExactChild(element, removed, nextTargets);\n\n            if (removedChild) {\n                const groupIndex = nextTargets.findIndex(target => {\n                    return isArray(target) && removedChild.compare(target);\n                });\n\n                if (groupIndex > -1) {\n                    nextTargets.splice(groupIndex, 1);\n                }\n            }\n        });\n\n        added.forEach(element => {\n            const parentGroup = this._findParentGroup(element, startSelected);\n\n            const nextChild = parentGroup.findContainedChild(element);\n\n            if (nextChild?.type === \"group\") {\n                nextTargets.push(nextChild.toTargetGroups());\n                return;\n            }\n            nextTargets.push(element);\n        });\n        return toTargetList(this.toChilds(nextTargets));\n    }\n    public selectSameDepthChilds(\n        targets: TargetGroupsType,\n        added: Array<HTMLElement | SVGElement>,\n        removed: Array<HTMLElement | SVGElement>,\n        continueSelect?: boolean,\n    ) {\n        const nextTargets = [...targets];\n        const commonParent = this.findCommonParent(nextTargets);\n\n        removed.forEach(element => {\n            // Single Target\n            const index = nextTargets.indexOf(element);\n\n            if (index > -1) {\n                // single target or group\n                nextTargets.splice(index, 1);\n                return;\n            }\n            const removedChild = continueSelect\n                // Find the nearest exact child for element, all removed and nextTargets.\n                ? commonParent.findNextExactChild(element, removed, nextTargets)\n                // Finds the nearest child for element and nextTargets.\n                : commonParent.findNextChild(element, nextTargets, true);\n\n            if (removedChild) {\n                const groupIndex = nextTargets.findIndex(target => {\n                    return isArray(target) && removedChild.compare(target);\n                });\n\n                if (groupIndex > -1) {\n                    nextTargets.splice(groupIndex, 1);\n                }\n            }\n        });\n        const addedChildren = commonParent.groupByPerfect(added);\n\n        addedChildren.forEach(child => {\n            if (child.type === \"single\") {\n                nextTargets.push(child.value);\n            } else {\n                const groupIndex = nextTargets.findIndex(target => {\n                    return isArray(target) && child.compare(target, 1);\n                });\n\n                if (groupIndex > -1) {\n                    nextTargets.splice(groupIndex, 1);\n                }\n                nextTargets.push(child.toTargetGroups());\n            }\n        });\n        return toTargetList(this.toChilds(nextTargets));\n    }\n    public toChilds(targets: TargetGroupsType): GroupChild[] {\n        const childs: GroupChild[] = [];\n\n        targets.forEach(target => {\n            if (isArray(target)) {\n                const arrayChild = this.findArrayChild(target);\n\n                if (arrayChild) {\n                    childs.push(arrayChild);\n                }\n            } else {\n                const single = this.map.get(target);\n\n                if (single) {\n                    childs.push(single);\n                } else {\n                    childs.push(new GroupSingleChild(this, target));\n                }\n            }\n        });\n\n        return childs;\n    }\n    public toSingleChild(element: HTMLElement | SVGElement, isAuto: true): GroupSingleChild;\n    public toSingleChild(element: HTMLElement | SVGElement, isAuto?: boolean): GroupSingleChild | undefined;\n    public toSingleChild(element: HTMLElement | SVGElement, isAuto?: boolean): GroupSingleChild | undefined {\n        const value = this.map.get(element);\n\n        if (isAuto) {\n            return value || new GroupSingleChild(this, element);\n        }\n        return value;\n    }\n    public findArrayChildById(id: string): GroupArrayChild | null {\n        let value: GroupArrayChild | null = null;\n\n        this.value.some(function find(child: GroupChild) {\n            if (child.type !== \"single\") {\n                if (child.id === id) {\n                    value = child;\n                    return true;\n                } else {\n                    return child.value.some(find);\n                }\n            }\n        });\n\n        return value;\n    }\n    public group(targets: TargetGroupsType, flatten?: boolean): TargetGroupsType | null {\n        const commonParent = this.findCommonParent(targets);\n        const groupChilds = targets.map(target => {\n            if (isArray(target)) {\n                return this.findArrayChild(target);\n            }\n            return this.toSingleChild(target);\n        });\n        const isGroupable = groupChilds.every(child => child?.parent === commonParent);\n\n        if (!isGroupable) {\n            return null;\n        }\n        const group = new GroupArrayChild(commonParent);\n        const nextChilds = commonParent.value.filter(target => groupChilds.indexOf(target) === -1);\n\n        nextChilds.unshift(group);\n\n        group.add(flatten ? deepFlat(targets) : targets);\n        commonParent.value = nextChilds;\n\n        this.set(this.toTargetGroups(), this._targets);\n\n        return group.toTargetGroups();\n    }\n    public ungroup(targets: TargetGroupsType) {\n        if (targets.length === 1 && isArray(targets[0])) {\n            targets = targets[0];\n        }\n        const commonParent = this.findCommonParent(targets);\n        const groupChilds = targets.map(target => {\n            if (isArray(target)) {\n                return this.findArrayChild(target);\n            }\n            return this.toSingleChild(target);\n        });\n        const isGroupable = commonParent.value.every(child => groupChilds.indexOf(child) > -1);\n\n        if (!isGroupable || commonParent === this) {\n            // has no group\n            return null;\n        }\n\n        const parent = commonParent.parent;\n\n        if (!parent) {\n            return null;\n        }\n        const nextChilds = parent.value.filter(target => target !== commonParent);\n\n        nextChilds.push(...commonParent.value);\n        parent.value = nextChilds;\n\n        this.set(this.toTargetGroups(), this._targets);\n        return commonParent.toTargetGroups();\n    }\n    protected _findParentGroup(\n        element: HTMLElement | SVGElement,\n        range: Array<HTMLElement | SVGElement>,\n    ) {\n        if (!range.length) {\n            return this;\n        }\n        const single = this.map.get(element);\n\n        if (!single) {\n            return this;\n        }\n        let parent: GroupArrayChild | undefined = single.parent;\n\n        while (parent) {\n            if (range.some(element => parent!.contains(element))) {\n                return parent;\n            }\n            parent = parent.parent;\n        }\n        return this;\n    }\n}\n"],"names":["Child","parent","this","type","depth","_scope","Object","defineProperty","prototype","get","__spreadArray","scope","id","GroupSingleChild","_super","value","_this","call","__extends","GroupArrayChild","apply","arguments","map","Map","__proto","compare","groups","checker","elements","deepFlat","elementsLength","length","mapSize","size","sizeDiff","count","filter","element","has","target","contains","some","child","findContainedChild","find","findExactChild","isArray","flatted","single","findCommonParent","targets","Infinity","childs","forEach","Math","min","firstChild","every","findNextChild","range","isExact","nextChild","toTargetGroups","nextGroupChild","findNextExactChild","selected","findPureChild","childSelected","findNextPureChild","findArrayChild","childResult_1","result","groupByPerfect","indexOf","add","group","groupId","push","children","current","set","toTargetList","raw","arr","flatten","GroupManager","targetGroups","_targets","selectSubChilds","targetChild","selectSingleChilds","added","removed","nextTargets","index","splice","toChilds","selectCompletedChilds","continueSelect","startSelected","removedChild","groupIndex","findIndex","_findParentGroup","selectSameDepthChilds","commonParent","arrayChild","toSingleChild","isAuto","findArrayChildById","nextChilds","groupChilds","unshift","ungroup"],"mappings":"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"}