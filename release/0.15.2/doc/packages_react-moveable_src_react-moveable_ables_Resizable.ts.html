<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>packages/react-moveable/src/react-moveable/ables/Resizable.ts - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/daybrush.css">
    <link type="text/css" rel="stylesheet" href="styles/custom.css">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <meta name="description" content="packages/react-moveable/src/react-moveable/ables/Resizable.ts - Documentation"/>

</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h2 class="custom"><a href="https://github.com/daybrush/moveable" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><div class="search"><div class="input-area"><input type="text"/></div><button></button></div><ul class="classes"><li file="moveable" class="parent"><a href="Moveable.html">Moveable</a><h4><a href="Moveable.html#members">Members</a></h4><ul class='members'><li data-type='method'><a href="Moveable.html#baseDirection">baseDirection</a></li><li data-type='method'><a href="Moveable.html#bounds">bounds</a></li><li data-type='method'><a href="Moveable.html#className">className</a></li><li data-type='method'><a href="Moveable.html#defaultGroupRotate">defaultGroupRotate</a></li><li data-type='method'><a href="Moveable.html#dragArea">dragArea</a></li><li data-type='method'><a href="Moveable.html#draggable">draggable</a></li><li data-type='method'><a href="Moveable.html#edge">edge</a></li><li data-type='method'><a href="Moveable.html#elementGuidelines">elementGuidelines</a></li><li data-type='method'><a href="Moveable.html#getScrollPosition">getScrollPosition</a></li><li data-type='method'><a href="Moveable.html#horizontalGuidlines">horizontalGuidlines</a></li><li data-type='method'><a href="Moveable.html#innerBounds">innerBounds</a></li><li data-type='method'><a href="Moveable.html#isDisplaySnapDigit">isDisplaySnapDigit</a></li><li data-type='method'><a href="Moveable.html#keepRatio">keepRatio</a></li><li data-type='method'><a href="Moveable.html#origin">origin</a></li><li data-type='method'><a href="Moveable.html#pinchable">pinchable</a></li><li data-type='method'><a href="Moveable.html#renderDirections">renderDirections</a></li><li data-type='method'><a href="Moveable.html#resizable">resizable</a></li><li data-type='method'><a href="Moveable.html#rotatable">rotatable</a></li><li data-type='method'><a href="Moveable.html#rotationPosition">rotationPosition</a></li><li data-type='method'><a href="Moveable.html#scalable">scalable</a></li><li data-type='method'><a href="Moveable.html#scrollable">scrollable</a></li><li data-type='method'><a href="Moveable.html#scrollContainer">scrollContainer</a></li><li data-type='method'><a href="Moveable.html#scrollThreshold">scrollThreshold</a></li><li data-type='method'><a href="Moveable.html#snapCenter">snapCenter</a></li><li data-type='method'><a href="Moveable.html#snapDigit">snapDigit</a></li><li data-type='method'><a href="Moveable.html#snapElement">snapElement</a></li><li data-type='method'><a href="Moveable.html#snapHorizontal">snapHorizontal</a></li><li data-type='method'><a href="Moveable.html#snappable">snappable</a></li><li data-type='method'><a href="Moveable.html#snapThreshold">snapThreshold</a></li><li data-type='method'><a href="Moveable.html#snapVertical">snapVertical</a></li><li data-type='method'><a href="Moveable.html#target">target</a></li><li data-type='method'><a href="Moveable.html#throttleDrag">throttleDrag</a></li><li data-type='method'><a href="Moveable.html#throttleDragRotate">throttleDragRotate</a></li><li data-type='method'><a href="Moveable.html#throttleResize">throttleResize</a></li><li data-type='method'><a href="Moveable.html#throttleRotate">throttleRotate</a></li><li data-type='method'><a href="Moveable.html#throttleScale">throttleScale</a></li><li data-type='method'><a href="Moveable.html#verticalGuidlines">verticalGuidlines</a></li><li data-type='method'><a href="Moveable.html#warpable">warpable</a></li><li data-type='method'><a href="Moveable.html#zoom">zoom</a></li></ul><h4><a href="Moveable.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="Moveable.html#destroy">destroy</a></li><li data-type='method'><a href="Moveable.html#dragStart">dragStart</a></li><li data-type='method'><a href="Moveable.html#getRect">getRect</a></li><li data-type='method'><a href="Moveable.html#hasOn">hasOn</a></li><li data-type='method'><a href="Moveable.html#isInside">isInside</a></li><li data-type='method'><a href="Moveable.html#isMoveableElement">isMoveableElement</a></li><li data-type='method'><a href="Moveable.html#off">off</a></li><li data-type='method'><a href="Moveable.html#on">on</a></li><li data-type='method'><a href="Moveable.html#once">once</a></li><li data-type='method'><a href="Moveable.html#request">request</a></li><li data-type='method'><a href="Moveable.html#trigger">trigger</a></li><li data-type='method'><a href="Moveable.html#updateRect">updateRect</a></li><li data-type='method'><a href="Moveable.html#updateTarget">updateTarget</a></li></ul><h4><a href="Moveable.html#events">Events</a></h4><ul class='events'><li data-type='event'><a href="Moveable.html#.event:click">click</a></li><li data-type='event'><a href="Moveable.html#.event:clickGroup">clickGroup</a></li><li data-type='event'><a href="Moveable.html#.event:drag">drag</a></li><li data-type='event'><a href="Moveable.html#.event:dragEnd">dragEnd</a></li><li data-type='event'><a href="Moveable.html#.event:dragGroup">dragGroup</a></li><li data-type='event'><a href="Moveable.html#.event:dragGroupEnd">dragGroupEnd</a></li><li data-type='event'><a href="Moveable.html#.event:dragGroupStart">dragGroupStart</a></li><li data-type='event'><a href="Moveable.html#.event:dragStart">dragStart</a></li><li data-type='event'><a href="Moveable.html#.event:pinch">pinch</a></li><li data-type='event'><a href="Moveable.html#.event:pinchEnd">pinchEnd</a></li><li data-type='event'><a href="Moveable.html#.event:pinchGroup">pinchGroup</a></li><li data-type='event'><a href="Moveable.html#.event:pinchGroupEnd">pinchGroupEnd</a></li><li data-type='event'><a href="Moveable.html#.event:pinchGroupStart">pinchGroupStart</a></li><li data-type='event'><a href="Moveable.html#.event:pinchStart">pinchStart</a></li><li data-type='event'><a href="Moveable.html#.event:render">render</a></li><li data-type='event'><a href="Moveable.html#.event:renderEnd">renderEnd</a></li><li data-type='event'><a href="Moveable.html#.event:renderGroup">renderGroup</a></li><li data-type='event'><a href="Moveable.html#.event:renderGroupEnd">renderGroupEnd</a></li><li data-type='event'><a href="Moveable.html#.event:renderGroupStart">renderGroupStart</a></li><li data-type='event'><a href="Moveable.html#.event:renderStart">renderStart</a></li><li data-type='event'><a href="Moveable.html#.event:resize">resize</a></li><li data-type='event'><a href="Moveable.html#.event:resizeEnd">resizeEnd</a></li><li data-type='event'><a href="Moveable.html#.event:resizeGroup">resizeGroup</a></li><li data-type='event'><a href="Moveable.html#.event:resizeGroupEnd">resizeGroupEnd</a></li><li data-type='event'><a href="Moveable.html#.event:resizeGroupStart">resizeGroupStart</a></li><li data-type='event'><a href="Moveable.html#.event:resizeStart">resizeStart</a></li><li data-type='event'><a href="Moveable.html#.event:rotate">rotate</a></li><li data-type='event'><a href="Moveable.html#.event:rotateEnd">rotateEnd</a></li><li data-type='event'><a href="Moveable.html#.event:rotateGroup">rotateGroup</a></li><li data-type='event'><a href="Moveable.html#.event:rotateGroupEnd">rotateGroupEnd</a></li><li data-type='event'><a href="Moveable.html#.event:rotateGroupStart">rotateGroupStart</a></li><li data-type='event'><a href="Moveable.html#.event:rotateStart">rotateStart</a></li><li data-type='event'><a href="Moveable.html#.event:scale">scale</a></li><li data-type='event'><a href="Moveable.html#.event:scaleEnd">scaleEnd</a></li><li data-type='event'><a href="Moveable.html#.event:scaleGroup">scaleGroup</a></li><li data-type='event'><a href="Moveable.html#.event:scaleGroupEnd">scaleGroupEnd</a></li><li data-type='event'><a href="Moveable.html#.event:scaleGroupStart">scaleGroupStart</a></li><li data-type='event'><a href="Moveable.html#.event:scaleStart">scaleStart</a></li><li data-type='event'><a href="Moveable.html#.event:scroll">scroll</a></li><li data-type='event'><a href="Moveable.html#.event:scrollGroup">scrollGroup</a></li><li data-type='event'><a href="Moveable.html#.event:warp">warp</a></li><li data-type='event'><a href="Moveable.html#.event:warpEnd">warpEnd</a></li><li data-type='event'><a href="Moveable.html#.event:warpStart">warpStart</a></li></ul><h4><a href="Moveable.html#type definitions">Type Definitions</a></h4><ul class='type definitions'><li data-type='typddef'><a href="Moveable.html#.AbleRequestParam">AbleRequestParam</a></li><li data-type='typddef'><a href="Moveable.html#.BoundType">BoundType</a></li><li data-type='typddef'><a href="Moveable.html#.DraggableOptions">DraggableOptions</a></li><li data-type='typddef'><a href="Moveable.html#.GroupableOptions">GroupableOptions</a></li><li data-type='typddef'><a href="Moveable.html#.InnerBoundType">InnerBoundType</a></li><li data-type='typddef'><a href="Moveable.html#.MoveableDefaultProps">MoveableDefaultProps</a></li><li data-type='typddef'><a href="Moveable.html#.MoveableOptions">MoveableOptions</a></li><li data-type='typddef'><a href="Moveable.html#.OnClick">OnClick</a></li><li data-type='typddef'><a href="Moveable.html#.OnClickGroup">OnClickGroup</a></li><li data-type='typddef'><a href="Moveable.html#.OnDrag">OnDrag</a></li><li data-type='typddef'><a href="Moveable.html#.OnDragEnd">OnDragEnd</a></li><li data-type='typddef'><a href="Moveable.html#.OnDragGroup">OnDragGroup</a></li><li data-type='typddef'><a href="Moveable.html#.OnDragGroupEnd">OnDragGroupEnd</a></li><li data-type='typddef'><a href="Moveable.html#.OnDragGroupStart">OnDragGroupStart</a></li><li data-type='typddef'><a href="Moveable.html#.OnDragStart">OnDragStart</a></li><li data-type='typddef'><a href="Moveable.html#.OnEvent">OnEvent</a></li><li data-type='typddef'><a href="Moveable.html#.OnPinch">OnPinch</a></li><li data-type='typddef'><a href="Moveable.html#.OnPinchEnd">OnPinchEnd</a></li><li data-type='typddef'><a href="Moveable.html#.OnPinchGroup">OnPinchGroup</a></li><li data-type='typddef'><a href="Moveable.html#.OnPinchGroupEnd">OnPinchGroupEnd</a></li><li data-type='typddef'><a href="Moveable.html#.OnPinchGroupStart">OnPinchGroupStart</a></li><li data-type='typddef'><a href="Moveable.html#.OnPinchStart">OnPinchStart</a></li><li data-type='typddef'><a href="Moveable.html#.OnRender">OnRender</a></li><li data-type='typddef'><a href="Moveable.html#.OnRenderEnd">OnRenderEnd</a></li><li data-type='typddef'><a href="Moveable.html#.OnRenderGroup">OnRenderGroup</a></li><li data-type='typddef'><a href="Moveable.html#.OnRenderGroupEnd">OnRenderGroupEnd</a></li><li data-type='typddef'><a href="Moveable.html#.OnRenderGroupStart">OnRenderGroupStart</a></li><li data-type='typddef'><a href="Moveable.html#.OnRenderStart">OnRenderStart</a></li><li data-type='typddef'><a href="Moveable.html#.OnResize">OnResize</a></li><li data-type='typddef'><a href="Moveable.html#.OnResizeEnd">OnResizeEnd</a></li><li data-type='typddef'><a href="Moveable.html#.OnResizeGroup">OnResizeGroup</a></li><li data-type='typddef'><a href="Moveable.html#.OnResizeGroupEnd">OnResizeGroupEnd</a></li><li data-type='typddef'><a href="Moveable.html#.OnResizeGroupStart">OnResizeGroupStart</a></li><li data-type='typddef'><a href="Moveable.html#.OnResizeStart">OnResizeStart</a></li><li data-type='typddef'><a href="Moveable.html#.OnRotate">OnRotate</a></li><li data-type='typddef'><a href="Moveable.html#.OnRotateEnd">OnRotateEnd</a></li><li data-type='typddef'><a href="Moveable.html#.OnRotateGroup">OnRotateGroup</a></li><li data-type='typddef'><a href="Moveable.html#.OnRotateGroupEnd">OnRotateGroupEnd</a></li><li data-type='typddef'><a href="Moveable.html#.OnRotateGroupStart">OnRotateGroupStart</a></li><li data-type='typddef'><a href="Moveable.html#.OnRotateStart">OnRotateStart</a></li><li data-type='typddef'><a href="Moveable.html#.OnScale">OnScale</a></li><li data-type='typddef'><a href="Moveable.html#.OnScaleEnd">OnScaleEnd</a></li><li data-type='typddef'><a href="Moveable.html#.OnScaleGroup">OnScaleGroup</a></li><li data-type='typddef'><a href="Moveable.html#.OnScaleGroupEnd">OnScaleGroupEnd</a></li><li data-type='typddef'><a href="Moveable.html#.OnScaleGroupStart">OnScaleGroupStart</a></li><li data-type='typddef'><a href="Moveable.html#.OnScaleStart">OnScaleStart</a></li><li data-type='typddef'><a href="Moveable.html#.OnScroll">OnScroll</a></li><li data-type='typddef'><a href="Moveable.html#.OnScrollGroup">OnScrollGroup</a></li><li data-type='typddef'><a href="Moveable.html#.OnWarp">OnWarp</a></li><li data-type='typddef'><a href="Moveable.html#.OnWarpEnd">OnWarpEnd</a></li><li data-type='typddef'><a href="Moveable.html#.OnWarpStart">OnWarpStart</a></li><li data-type='typddef'><a href="Moveable.html#.PinchableOptions">PinchableOptions</a></li><li data-type='typddef'><a href="Moveable.html#.RectInfo">RectInfo</a></li><li data-type='typddef'><a href="Moveable.html#.Requester">Requester</a></li><li data-type='typddef'><a href="Moveable.html#.ResizableOptions">ResizableOptions</a></li><li data-type='typddef'><a href="Moveable.html#.RotatableOptions">RotatableOptions</a></li><li data-type='typddef'><a href="Moveable.html#.ScalableOptions">ScalableOptions</a></li><li data-type='typddef'><a href="Moveable.html#.ScrollableOptions">ScrollableOptions</a></li><li data-type='typddef'><a href="Moveable.html#.SnappableProps">SnappableProps</a></li><li data-type='typddef'><a href="Moveable.html#.WarpableOptions">WarpableOptions</a></li></ul></li><li file="component" class="parent"><a href="eg.Component.html">eg.Component</a><h4><a href="eg.Component.html#static members">Static Members</a></h4><ul class='static members'><li data-type='member'><a href="eg.Component.html#.VERSION">VERSION</a></li></ul><h4><a href="eg.Component.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="eg.Component.html#hasOn">hasOn</a></li><li data-type='method'><a href="eg.Component.html#off">off</a></li><li data-type='method'><a href="eg.Component.html#on">on</a></li><li data-type='method'><a href="eg.Component.html#once">once</a></li><li data-type='method'><a href="eg.Component.html#trigger">trigger</a></li></ul></li></ul><ul class="namespaces"><li file="draggable" class="parent"><a href="Moveable.Draggable.html">Moveable.Draggable</a><h4><a href="Moveable.Draggable.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="Moveable.Draggable.html#request">request</a></li></ul></li><li file="resizable" class="parent"><a href="Moveable.Resizable.html">Moveable.Resizable</a><h4><a href="Moveable.Resizable.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="Moveable.Resizable.html#request">request</a></li></ul></li><li file="rotatable" class="parent"><a href="Moveable.Rotatable.html">Moveable.Rotatable</a><h4><a href="Moveable.Rotatable.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="Moveable.Rotatable.html#request">request</a></li></ul></li><li file="scalable" class="parent"><a href="Moveable.Scalable.html">Moveable.Scalable</a><h4><a href="Moveable.Scalable.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="Moveable.Scalable.html#request">request</a></li></ul></li></ul><ul class="global"><li file="global"  class="parent"><a href="global.html">Global</a><h4><a href="global.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="global.html#isUndefined">isUndefined</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">packages/react-moveable/src/react-moveable/ables/Resizable.ts</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {
    throttle, getDirection, triggerEvent,
    getAbsolutePosesByState, fillParams, getKeepRatioHeight, getKeepRatioWidth, getCSSSize, getDistSize,
} from "../utils";
import {
    setDragStart,
    getDragDist,
    getResizeDist,
    getPosByReverseDirection,
    getStartDirection,
    getAbsoluteFixedPosition,
} from "../DraggerUtils";
import {
    ResizableProps, OnResizeGroup, OnResizeGroupEnd,
    Renderer, OnResizeGroupStart, DraggableProps, OnDrag, OnResizeStart, SnappableState,
    OnResize, OnResizeEnd,
} from "../types";
import MoveableManager from "../MoveableManager";
import { renderAllDirections, renderDiagonalDirections } from "../renderDirection";
import MoveableGroup from "../MoveableGroup";
import {
    triggerChildAble,
} from "../groupUtils";
import Draggable from "./Draggable";
import { getRad, caculate, createRotateMatrix, plus } from "@moveable/matrix";
import CustomDragger, { setCustomDrag } from "../CustomDragger";
import { checkSnapSize } from "./Snappable";
import {
    directionCondition,
} from "./utils";
import { IObject } from "@daybrush/utils";
import { TINY_NUM } from "../consts";

/**
 * @namespace Resizable
 * @memberof Moveable
 */

export default {
    name: "resizable",
    ableGroup: "size",
    updateRect: true,
    canPinch: true,
    props: {
        resizable: Boolean,
        throttleResize: Number,
        renderDirections: Array,
        baseDirection: Array,
        keepRatio: Boolean,
    },
    render(moveable: MoveableManager&lt;Partial&lt;ResizableProps>>, React: Renderer): any[] | undefined {
        const { resizable, edge } = moveable.props;
        if (resizable) {
            if (edge) {
                return renderDiagonalDirections(moveable, React);
            }
            return renderAllDirections(moveable, React);
        }
    },
    dragControlCondition: directionCondition,
    dragControlStart(
        moveable: MoveableManager&lt;ResizableProps &amp; DraggableProps, SnappableState>,
        e: any,
    ) {
        const {
            inputEvent,
            pinchFlag,
            parentDirection,
            datas,
        } = e;

        const direction = parentDirection || (pinchFlag ? [1, 1] : getDirection(inputEvent.target));

        const { target, width, height } = moveable.state;

        if (!direction || !target) {
            return false;
        }
        !pinchFlag &amp;&amp; setDragStart(moveable, { datas });

        datas.datas = {};
        datas.direction = direction;
        datas.startOffsetWidth = width;
        datas.startOffsetHeight = height;
        datas.prevWidth = 0;
        datas.prevHeight = 0;
        [
            datas.startWidth,
            datas.startHeight,
        ] = getCSSSize(target);
        datas.transformOrigin = moveable.props.transformOrigin;
        datas.startDirection = getStartDirection(moveable, direction);
        datas.fixedPosition = getAbsoluteFixedPosition(moveable, datas.startDirection);
        datas.fixedOriginalPosition = getAbsoluteFixedPosition(moveable, direction);

        const params = fillParams&lt;OnResizeStart>(moveable, e, {
            direction,
            set: ([startWidth, startHeight]: number[]) => {
                datas.startWidth = startWidth;
                datas.startHeight = startHeight;
            },
            setOrigin: (origin: Array&lt;string | number>) => {
                datas.transformOrigin = origin;
            },
            dragStart: Draggable.dragStart(
                moveable,
                new CustomDragger().dragStart([0, 0], inputEvent),
            ),
        });
        const result = triggerEvent(moveable, "onResizeStart", params);
        if (result !== false) {
            datas.isResize = true;
            moveable.state.snapRenderInfo = {
                direction,
            };
        }
        return datas.isResize ? params : false;
    },
    dragControl(
        moveable: MoveableManager&lt;ResizableProps &amp; DraggableProps>,
        e: any,
    ) {
        const {
            datas,
            distX, distY,
            parentFlag, pinchFlag,
            parentDistance, parentScale, inputEvent,
            parentKeepRatio,
            dragClient,
            parentDist,
        } = e;
        const {
            direction,
            isResize,
            transformOrigin,
        } = datas;

        if (!isResize) {
            return;
        }
        const {
            startWidth,
            startHeight,
            startOffsetWidth,
            startOffsetHeight,
            prevWidth,
            prevHeight,
        } = datas;
        const {
            throttleResize = 0,
            parentMoveable,
        } = moveable.props;
        let sizeDirection = direction;

        if (!direction[0] &amp;&amp; !direction[1]) {
            sizeDirection = [1, 1];
        }
        const keepRatio = moveable.props.keepRatio || parentKeepRatio;
        const isWidth = sizeDirection[0] || !sizeDirection[1];
        const ratio = isWidth ? startOffsetHeight / startOffsetWidth : startOffsetWidth / startOffsetHeight;
        const startDirection = keepRatio || parentFlag ? direction : datas.startDirection;
        const fixedPosition = dragClient || (keepRatio ? datas.fixedOriginalPosition : datas.fixedPosition);
        let distWidth: number = 0;
        let distHeight: number = 0;

        if (parentDist) {
            distWidth = parentDist[0];
            distHeight = parentDist[1];
        } else if (parentScale) {
            distWidth = (parentScale[0] - 1) * startOffsetWidth;
            distHeight = (parentScale[1] - 1) * startOffsetHeight;

        } else if (pinchFlag) {
            if (parentDistance) {
                distWidth = parentDistance;
                distHeight = parentDistance * startOffsetHeight / startOffsetWidth;
            }
        } else {
            const dist = getDragDist({ datas, distX, distY });

            distWidth = sizeDirection[0] * dist[0];
            distHeight = sizeDirection[1] * dist[1];

            if (keepRatio &amp;&amp; startOffsetWidth &amp;&amp; startOffsetHeight) {
                const rad = getRad([0, 0], dist);
                const standardRad = getRad([0, 0], sizeDirection);
                const ratioRad = getRad([0, 0], [startOffsetWidth, startOffsetHeight]);
                const size = getDistSize([distWidth, distHeight]);
                const signSize = Math.cos(rad - standardRad) * size;

                if (!sizeDirection[0]) {
                    // top, bottom
                    distHeight = signSize;
                    distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);
                } else if (!sizeDirection[1]) {
                    // left, right
                    distWidth = signSize;
                    distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);
                } else {
                    // two-way
                    distWidth = Math.cos(ratioRad) * signSize;
                    distHeight = Math.sin(ratioRad) * signSize;
                }
            }
        }
        let nextWidth = sizeDirection[0] || keepRatio
            ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;
        let nextHeight = sizeDirection[1] || keepRatio
            ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;

        if (keepRatio &amp;&amp; startOffsetWidth &amp;&amp; startOffsetHeight) {
            // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight
            nextHeight = nextWidth * startOffsetHeight / startOffsetWidth;
        }
        let snapDist = [0, 0];

        if (!pinchFlag) {
            snapDist = checkSnapSize(
                moveable, nextWidth,
                nextHeight, direction,
                datas.fixedOriginalPosition,
                parentDist,
                datas,
            );
        }
        if (parentDist) {
            !parentDist[0] &amp;&amp; (snapDist[0] = 0);
            !parentDist[1] &amp;&amp; (snapDist[1] = 0);
        }
        if (keepRatio) {
            if (sizeDirection[0] &amp;&amp; sizeDirection[1] &amp;&amp; snapDist[0] &amp;&amp; snapDist[1]) {
                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {
                    snapDist[1] = 0;
                } else {
                    snapDist[0] = 0;
                }
            }
            const isNoSnap = !snapDist[0] &amp;&amp; !snapDist[1];

            if (isNoSnap) {
                if (isWidth) {
                    nextWidth = throttle(nextWidth, throttleResize!);
                } else {
                    nextHeight = throttle(nextHeight, throttleResize!);
                }
            }
            if (
                (sizeDirection[0] &amp;&amp; !sizeDirection[1])
                || (snapDist[0] &amp;&amp; !snapDist[1])
                || (isNoSnap &amp;&amp; isWidth)
            ) {
                nextWidth += snapDist[0];
                nextHeight = getKeepRatioHeight(nextWidth, isWidth, ratio);
            } else if (
                (!sizeDirection[0] &amp;&amp; sizeDirection[1])
                || (!snapDist[0] &amp;&amp; snapDist[1])
                || (isNoSnap &amp;&amp; !isWidth)
            ) {
                nextHeight += snapDist[1];
                nextWidth = getKeepRatioWidth(nextHeight, isWidth, ratio);
            }
        } else {
            nextWidth += snapDist[0];
            nextHeight += snapDist[1];
            if (!snapDist[0]) {
                nextWidth = throttle(nextWidth, throttleResize!);
            }
            if (!snapDist[1]) {
                nextHeight = throttle(nextHeight, throttleResize!);
            }
        }
        nextWidth = Math.round(nextWidth);
        nextHeight = Math.round(nextHeight);

        distWidth = nextWidth - startOffsetWidth;
        distHeight = nextHeight - startOffsetHeight;

        const delta = [distWidth - prevWidth, distHeight - prevHeight];

        datas.prevWidth = distWidth;
        datas.prevHeight = distHeight;

        if (!parentMoveable &amp;&amp; delta.every(num => !num)) {
            return;
        }

        const inverseDelta = !parentFlag &amp;&amp; pinchFlag
            ? [0, 0]
            : getResizeDist(
                moveable,
                nextWidth, nextHeight,
                startDirection, fixedPosition, transformOrigin);

        const params = fillParams&lt;OnResize>(moveable, e, {
            width: startWidth + distWidth,
            height: startHeight + distHeight,
            offsetWidth: nextWidth,
            offsetHeight: nextHeight,
            direction,
            dist: [distWidth, distHeight],
            delta,
            isPinch: !!pinchFlag,
            drag: Draggable.drag(
                moveable,
                setCustomDrag(moveable.state, inverseDelta, inputEvent, false),
            ) as OnDrag,
        });
        triggerEvent(moveable, "onResize", params);
        return params;
    },
    dragControlAfter(
        moveable: MoveableManager&lt;ResizableProps &amp; DraggableProps>,
        e: any,
    ) {
        const datas = e.datas;
        const {
            isResize,
            startOffsetWidth,
            startOffsetHeight,
            prevWidth,
            prevHeight,
        } = datas;

        if (!isResize) {
            return;
        }
        const {
            width,
            height,
        } = moveable.state;
        const errorWidth = width - (startOffsetWidth + prevWidth);
        const errorHeight = height - (startOffsetHeight + prevHeight);
        const isErrorWidth = Math.abs(errorWidth) > 3;
        const isErrorHeight = Math.abs(errorHeight) > 3;

        if (isErrorWidth) {
            datas.startWidth += errorWidth;
            datas.startOffsetWidth += errorWidth;
            datas.prevWidth += errorWidth;
        }
        if (isErrorHeight) {
            datas.startHeight += errorHeight;
            datas.startOffsetHeight += errorHeight;
            datas.prevHeight += errorHeight;
        }
        if (isErrorWidth || isErrorHeight) {
            this.dragControl(moveable, e);
            return true;
        }
    },
    dragControlEnd(
        moveable: MoveableManager&lt;ResizableProps &amp; DraggableProps>,
        e: any,
    ) {
        const { datas, isDrag } = e;
        if (!datas.isResize) {
            return false;
        }
        datas.isResize = false;

        const params = fillParams&lt;OnResizeEnd>(moveable, e, {
            isDrag,
        });
        triggerEvent(moveable, "onResizeEnd", params);
        return isDrag;
    },
    dragGroupControlCondition: directionCondition,
    dragGroupControlStart(moveable: MoveableGroup, e: any) {
        const { datas } = e;
        const params = this.dragControlStart(moveable, e);

        if (!params) {
            return false;
        }
        const direction = params.direction;
        const startPos = getPosByReverseDirection(getAbsolutePosesByState(moveable.state), direction);

        const events = triggerChildAble(
            moveable,
            this,
            "dragControlStart",
            datas,
            (child, childDatas) => {
                const pos = getPosByReverseDirection(getAbsolutePosesByState(child.state), direction);
                const [originalX, originalY] = caculate(
                    createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),
                    [pos[0] - startPos[0], pos[1] - startPos[1], 1],
                    3,
                );
                childDatas.originalX = originalX;
                childDatas.originalY = originalY;

                return e;
            },
        );

        const nextParams: OnResizeGroupStart = {
            ...params,
            targets: moveable.props.targets!,
            events,
        };
        const result = triggerEvent(moveable, "onResizeGroupStart", nextParams);

        datas.isResize = result !== false;
        return datas.isResize ? params : false;
    },
    dragGroupControl(moveable: MoveableGroup, e: any) {
        const { datas } = e;
        if (!datas.isResize) {
            return;
        }
        const params = this.dragControl(moveable, e);

        if (!params) {
            return;
        }
        const {
            offsetWidth, offsetHeight, dist,
        } = params;

        const keepRatio = moveable.props.keepRatio;

        const parentScale = [
            offsetWidth / (offsetWidth - dist[0]),
            offsetHeight / (offsetHeight - dist[1]),
        ];
        const fixedPosition = datas.fixedOriginalPosition;

        const events = triggerChildAble(
            moveable,
            this,
            "dragControl",
            datas,
            (_, childDatas) => {
                const [clientX, clientY] = caculate(
                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),
                    [
                        childDatas.originalX * parentScale[0],
                        childDatas.originalY * parentScale[1],
                        1,
                    ],
                    3,
                );

                return {
                    ...e,
                    parentScale,
                    dragClient: plus(fixedPosition, [clientX, clientY]),
                    parentKeepRatio: keepRatio,
                };
            },
        );
        const nextParams: OnResizeGroup = {
            targets: moveable.props.targets!,
            events,
            ...params,
        };

        triggerEvent(moveable, "onResizeGroup", nextParams);
        return nextParams;
    },
    dragGroupControlEnd(moveable: MoveableGroup, e: any) {
        const { isDrag, datas } = e;

        if (!datas.isResize) {
            return;
        }

        this.dragControlEnd(moveable, e);
        triggerChildAble(moveable, this, "dragControlEnd", datas, e);

        const nextParams: OnResizeGroupEnd = fillParams&lt;OnResizeGroupEnd>(moveable, e, {
            targets: moveable.props.targets!,
            isDrag,
        });

        triggerEvent(moveable, "onResizeGroupEnd", nextParams);
        return isDrag;
    },
    /**
     * @method Moveable.Resizable#request
     * @param {object} [e] - the Resizable's request parameter
     * @param {number} [e.direction=[1, 1]] - Direction to resize
     * @param {number} [e.deltaWidth] - delta number of width
     * @param {number} [e.deltaHeight] - delta number of height
     * @param {number} [e.isInstant] - Whether to execute the request instantly
     * @return {Moveable.Requester} Moveable Requester
     * @example

     * // Instantly Request (requestStart - request - requestEnd)
     * // Use Relative Value
     * moveable.request("resizable", { deltaWidth: 10, deltaHeight: 10, isInstant: true });
     *
     * // Use Absolute Value
     * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100, isInstant: true });
     *
     * // requestStart
     * const requester = moveable.request("resizable");
     *
     * // request
     * // Use Relative Value
     * requester.request({ deltaWidth: 10, deltaHeight: 10 });
     * requester.request({ deltaWidth: 10, deltaHeight: 10 });
     * requester.request({ deltaWidth: 10, deltaHeight: 10 });
     *
     * // Use Absolute Value
     * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100, isInstant: true });
     * moveable.request("resizable", { offsetWidth: 110, offsetHeight: 100, isInstant: true });
     * moveable.request("resizable", { offsetWidth: 120, offsetHeight: 100, isInstant: true });
     *
     * // requestEnd
     * requester.requestEnd();
     */
    request(moveable: MoveableManager&lt;any>) {
        const datas = {};
        let distWidth = 0;
        let distHeight = 0;
        const rect = moveable.getRect();

        return {
            isControl: true,
            requestStart(e: IObject&lt;any>) {
                return { datas, parentDirection: e.direction || [1, 1] };
            },
            request(e: IObject&lt;any>) {
                if ("offsetWidth" in e) {
                    distWidth = e.offsetWidth - rect.offsetWidth;
                } else if ("deltaWidth" in e) {
                    distWidth += e.deltaWidth;
                }
                if ("offsetHeight" in e) {
                    distHeight = e.offsetHeight - rect.offsetHeight;
                } else if ("deltaHeight" in e) {
                    distHeight += e.deltaHeight;
                }

                return { datas, parentDist: [distWidth, distHeight] };
            },
            requestEnd() {
                return { datas, isDrag: true };
            },
        };
    },
};
</code></pre>
        </article>
    </section>





<style>


nav li[file="packages/react-moveable/src/react-moveable/ables/resizable"]:after {
    display: none;
}
nav li[file="packages/react-moveable/src/react-moveable/ables/resizable"] h4, nav li[file="packages/react-moveable/src/react-moveable/ables/resizable"] ul {
    display: block;
}
</style>

</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/daybrush/jsdoc">JSDoc 0.3.7</a> on Thu Mar 05 2020 13:03:48 GMT+0900 (GMT+09:00) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/utils.min.js"></script>
<script src="scripts/search.js"></script>
<script src="scripts/custom.js"></script>
</body>
</html>
