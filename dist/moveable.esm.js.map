{"version":3,"file":"moveable.esm.js","sources":["../src/InnerMoveable.tsx","../src/consts.ts","../src/Moveable.tsx"],"sourcesContent":["import { Component, h } from \"preact\";\nimport { createPortal } from \"preact/compat\";\nimport Moveable, { MoveableProps, PreactMoveableInterface } from \"preact-moveable\";\nimport { ref } from \"framework-utils\";\n\nexport default class InnerMoveable extends Component<MoveableProps> {\n    public state: MoveableProps = {};\n    public preactMoveable: PreactMoveableInterface;\n    constructor(props: MoveableProps) {\n        super(props);\n        this.state = this.props;\n    }\n    public render() {\n        return createPortal(<Moveable ref={ref(this, \"preactMoveable\")} {...this.state} />, this.state.parentElement);\n    }\n}\n","import { MoveableEvents, MoveableOptions } from \"./types\";\n\nexport const PROPERTIES: Array<keyof MoveableOptions> = [\n    \"draggable\", \"resizable\", \"scalable\", \"rotatable\",\n    \"warpable\", \"pinchable\", \"snappable\", \"origin\", \"target\", \"edge\",\n    \"throttleDrag\", \"throttleResize\",\n    \"throttleScale\", \"throttleRotate\", \"keepRatio\",\n    \"dragArea\",\n    \"pinchThreshold\",\n    \"snapCenter\", \"snapThreshold\",\n    \"horizontalGuidelines\", \"verticalGuidelines\", \"elementGuidelines\",\n    \"bounds\",\n\n    \"className\",\n    \"renderDirections\",\n    \"scrollable\",\n    \"getScrollPosition\",\n    \"scrollContainer\",\n    \"scrollThreshold\",\n    \"baseDirection\",\n];\nexport const EVENTS: Array<keyof MoveableEvents> = [\n    \"dragStart\",\n    \"drag\",\n    \"dragEnd\",\n    \"resizeStart\",\n    \"resize\",\n    \"resizeEnd\",\n    \"scaleStart\",\n    \"scale\",\n    \"scaleEnd\",\n    \"rotateStart\",\n    \"rotate\",\n    \"rotateEnd\",\n    \"warpStart\",\n    \"warp\",\n    \"warpEnd\",\n    \"pinchStart\",\n    \"pinch\",\n    \"pinchEnd\",\n    \"dragGroupStart\",\n    \"dragGroup\",\n    \"dragGroupEnd\",\n    \"resizeGroupStart\",\n    \"resizeGroup\",\n    \"resizeGroupEnd\",\n    \"scaleGroupStart\",\n    \"scaleGroup\",\n    \"scaleGroupEnd\",\n    \"rotateGroupStart\",\n    \"rotateGroup\",\n    \"rotateGroupEnd\",\n    \"pinchGroupStart\",\n    \"pinchGroup\",\n    \"pinchGroupEnd\",\n    \"clickGroup\",\n\n    \"scroll\",\n    \"scrollGroup\",\n\n    \"renderStart\",\n    \"render\",\n    \"renderEnd\",\n    \"renderGroupStart\",\n    \"renderGroup\",\n    \"renderGroupEnd\",\n];\n","import EgComponent from \"@egjs/component\";\nimport { ref, Properties } from \"framework-utils\";\nimport { h, render } from \"preact\";\nimport InnerMoveable from \"./InnerMoveable\";\nimport { MoveableOptions, MoveableGetterSetter } from \"./types\";\nimport {\n    OnDragStart, OnDrag, OnResize, OnResizeStart,\n    OnResizeEnd, OnScaleStart, OnScaleEnd, OnRotateStart,\n    OnRotateEnd, OnDragEnd, OnRotate, OnScale,\n    OnWarpStart, OnWarpEnd, OnWarp, OnPinchStart,\n    OnPinch, OnPinchEnd, OnDragGroup, OnDragGroupStart,\n    OnDragGroupEnd, OnResizeGroup, OnResizeGroupStart,\n    OnResizeGroupEnd, OnScaleGroup, OnScaleGroupEnd,\n    OnRotateGroup, OnRotateGroupStart, OnRotateGroupEnd,\n    OnPinchGroup, OnPinchGroupStart, OnPinchGroupEnd, OnScaleGroupStart, OnClickGroup,\n    MoveableInterface,\n    RectInfo,\n    OnClick,\n    OnScroll,\n    OnScrollGroup,\n    OnRenderStart,\n    OnRender,\n    OnRenderEnd,\n    OnRenderGroupStart,\n    OnRenderGroup,\n    OnRenderGroupEnd,\n} from \"react-moveable/declaration/types\";\nimport { PROPERTIES, EVENTS } from \"./consts\";\nimport { camelize, isArray } from \"@daybrush/utils\";\n\n/**\n * Moveable is Draggable! Resizable! Scalable! Rotatable!\n * @sort 1\n * @extends eg.Component\n */\n@Properties(PROPERTIES, (prototype, property) => {\n    Object.defineProperty(prototype, property, {\n        get() {\n            return this.getMoveable().props[property];\n        },\n        set(value) {\n            this.setState({\n                [property]: value,\n            });\n        },\n        enumerable: true,\n        configurable: true,\n    });\n})\nclass Moveable extends EgComponent implements MoveableInterface {\n    private innerMoveable!: InnerMoveable;\n    private tempElement = document.createElement(\"div\");\n\n    /**\n     *\n     */\n    constructor(parentElement: HTMLElement | SVGElement, options: MoveableOptions = {}) {\n        super();\n        const nextOptions = { container: parentElement, ...options };\n\n        const events: any = {};\n\n        EVENTS.forEach(name => {\n            events[camelize(`on ${name}`)] = (e: any) => this.trigger(name, e);\n        });\n\n        render(\n            <InnerMoveable\n                ref={ref(this, \"innerMoveable\")}\n                parentElement={parentElement}\n                {...nextOptions}\n                {...events}\n            />,\n            this.tempElement,\n        );\n        const target = nextOptions.target!;\n        if (isArray(target) && target.length > 1) {\n            this.updateRect();\n        }\n    }\n    /**\n     * Check if the target is an element included in the moveable.\n     * @param - the target\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"click\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *         moveable.target = e.target;\n     *     }\n     * });\n     */\n    public isMoveableElement(target: HTMLElement | SVGElement) {\n        return this.getMoveable().isMoveableElement(target);\n    }\n    /**\n     * If the width, height, left, and top of all elements change, update the shape of the moveable.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"resize\", e => {\n     *     moveable.updateRect();\n     * });\n     */\n    public updateRect() {\n        this.getMoveable().updateRect();\n    }\n    /**\n     * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\n     * @param - external `MouseEvent`or `TouchEvent`\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *          moveable.dragStart(e);\n     *     }\n     * });\n     */\n    public dragStart(e: MouseEvent | TouchEvent): void {\n        this.getMoveable().dragStart(e);\n    }\n\n    /**\n     * Whether the coordinates are inside Moveable\n     * @param - x coordinate\n     * @param - y coordinate\n     * @return - True if the coordinate is in moveable or false\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.isInside(e.clientX, e.clientY)) {\n     *          console.log(\"inside\");\n     *     }\n     * });\n     */\n    public isInside(clientX: number, clientY: number): boolean {\n        return this.getMoveable().isInside(clientX, clientY);\n    }\n    /**\n     * You can get the vertex information, position and offset size information of the target based on the container.\n     * @return - The Rect Info\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * const rectInfo = moveable.getRect();\n     */\n    public getRect(): RectInfo {\n        return this.getMoveable().getRect();\n    }\n    /**\n     * You can change options or properties dynamically.\n     * @param - options or properties\n     * @param - After the change, the callback function is executed when the update is completed.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.setState({\n     *   target: document.querySelector(\".target\"),\n     * }, () => {\n     *   moveable.dragStart(e);\n     * })\n     */\n    public setState(state: Partial<MoveableOptions>, callback?: () => any) {\n        this.innerMoveable.setState(state, callback);\n    }\n    /**\n     * If the width, height, left, and top of the only target change, update the shape of the moveable.\n     * @param - the values of x and y to move moveable.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.updateTarget();\n     */\n    public updateTarget(): void {\n        this.getMoveable().updateTarget();\n    }\n    /**\n     * Remove the Moveable object and the events.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.destroy();\n     */\n    public destroy() {\n        render(\"\", this.tempElement);\n        this.off();\n        this.tempElement = null;\n        this.innerMoveable = null;\n    }\n    private getMoveable() {\n        return this.innerMoveable.preactMoveable;\n    }\n}\n/**\n * Whether or not the origin controlbox will be visible or not (default: true)\n * @name Moveable#origin\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.origin = true;\n */\n/**\n * The target to indicate Moveable Control Box.\n * @name Moveable#target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n */\n/**\n * Whether or not target can be dragged. (default: false)\n * @name Moveable#draggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.draggable = true;\n */\n/**\n * Whether or not target can be resized. (default: false)\n * @name Moveable#resizable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.resizable = true;\n */\n/**\n * Whether or not target can scaled. (default: false)\n * @name Moveable#scalable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.scalable = true;\n */\n/**\n * Whether or not target can be rotated. (default: false)\n * @name Moveable#rotatable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.rotatable = true;\n */\n/**\n * Whether or not target can be warped. (default: false)\n * @name Moveable#warpable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.warpable = true;\n */\n/**\n * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n * @name Moveable#pinchable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.pinchable = true;\n */\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.keepRatio = true;\n */\n/**\n * Resize, Scale Events at edges\n * @name Moveable#edge\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.edge = true;\n */\n/**\n * throttle of x, y when drag.\n * @name Moveable#throttleDrag\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleDrag = 1;\n */\n/**\n * throttle of width, height when resize.\n * @name Moveable#throttleResize\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleResize = 1;\n */\n/**\n * throttle of scaleX, scaleY when scale.\n * @name Moveable#throttleScale\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleScale = 0.1;\n */\n/**\n * throttle of angle(degree) when rotate.\n * @name Moveable#throttleRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleRotate = 1;\n */\n\n /**\n * Whether or not target can be snapped to the guideline. (default: false)\n * @name Moveable#snappable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snappable = true;\n */\n/**\n * When you drag, make the snap in the center of the target. (default: false)\n * @name Moveable#snapCenter\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapCenter = true;\n */\n\n/**\n * Distance value that can snap to guidelines. (default: 5)\n * @name Moveable#snapThreshold\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapThreshold = 5;\n */\n\n/**\n * Add guidelines in the horizontal direction. (default: [])\n * @name Moveable#horizontalGuidlines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.horizontalGuidlines = [100, 200, 500];\n */\n\n/**\n * Add guidelines in the vertical direction. (default: [])\n * @name Moveable#\n * moveable.verticalGuidlines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.verticalGuidlines = [100, 200, 500];\n */\n/**\n * Add guidelines for the element. (default: [])\n * @name Moveable#elementGuidelines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.elementGuidelines = [\n *   document.querySelector(\".element\"),\n * ];\n */\n/**\n * You can set up boundaries. (default: [])\n * @name Moveable#bounds\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};\n */\n/**\n * Add an event to the moveable area instead of the target for stopPropagation. (default: false)\n * @name Moveable#dragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n/**\n * You can specify the position of the rotation. (default: \"top\")\n * @name Moveable#rotationPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   rotationPosition: \"top\",\n * });\n *\n * moveable.rotationPosition = \"bottom\"\n */\n/**\n * You can specify the className of the moveable controlbox. (default: \"\")\n * @name Moveable#className\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   className: \"\",\n * });\n *\n * moveable.className = \"moveable1\";\n */\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n\n /**\n * Set target's base direciton using top, left, right, bottom\n * (top: -1, left: -1, right: 1, bottom: 1) (default: [-1, -1])\n * @name Moveable#baseDirection\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   baseDirection: [-1, -1]\n * });\n *\n * moveable.baseDirection = [-1, -1];\n */\n\n /**\n * Sets the initial rotation of the group. (default 0)\n * @name Moveable#defaultGroupRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupRotate: 0,\n * });\n *\n * moveable.defaultGroupRotate = 40;\n */\n\n/**\n * Whether or not target can be scrolled to the scroll container (default: false)\n * @name Moveable#scrollable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n * moveable.scrollable = true;\n */\n\n/**\n * The container to which scroll is applied (default: container)\n * @name Moveable#scrollContainer\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n/**\n * Expand the range of the scroll check area. (default: 0)\n * @name Moveable#scrollThreshold\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n\n/**\n * Sets a function to get the scroll position. (default: Function)\n * @name Moveable#getScrollPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n */\n\n/**\n * When the drag starts, the dragStart event is called.\n * @memberof Moveable\n * @event dragStart\n * @param {Moveable.OnDragStart} - Parameters for the dragStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When dragging, the drag event is called.\n * @memberof Moveable\n * @event drag\n * @param {Moveable.OnDrag} - Parameters for the drag event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"drag\", ({ target, transform }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the drag finishes, the dragEnd event is called.\n * @memberof Moveable\n * @event dragEnd\n * @param {Moveable.OnDragEnd} - Parameters for the dragEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n /**\n * When the group drag starts, the `dragGroupStart` event is called.\n * @memberof Moveable\n * @event dragGroupStart\n * @param {Moveable.OnDragGroupStart} - Parameters for the `dragGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupStart\", ({ targets }) => {\n *     console.log(\"onDragGroupStart\", targets);\n * });\n */\n\n /**\n * When the group drag, the `dragGroup` event is called.\n * @memberof Moveable\n * @event dragGroup\n * @param {Moveable.onDragGroup} - Parameters for the `dragGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroup\", ({ targets, events }) => {\n *     console.log(\"onDragGroup\", targets);\n *     events.forEach(ev => {\n *          // drag event\n *          console.log(\"onDrag left, top\", ev.left, ev.top);\n *          // ev.target!.style.left = `${ev.left}px`;\n *          // ev.target!.style.top = `${ev.top}px`;\n *          console.log(\"onDrag translate\", ev.dist);\n *          ev.target!.style.transform = ev.transform;)\n *     });\n * });\n */\n\n/**\n * When the group drag finishes, the `dragGroupEnd` event is called.\n * @memberof Moveable\n * @event dragGroupEnd\n * @param {Moveable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onDragGroupEnd\", targets, isDrag);\n * });\n */\n\n/**\n * When the resize starts, the resizeStart event is called.\n * @memberof Moveable\n * @event resizeStart\n * @param {Moveable.OnResizeStart} - Parameters for the resizeStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When resizing, the resize event is called.\n * @memberof Moveable\n * @event resize\n * @param {Moveable.OnResize} - Parameters for the resize event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resize\", ({ target, width, height }) => {\n *     target.style.width = `${e.width}px`;\n *     target.style.height = `${e.height}px`;\n * });\n */\n/**\n * When the resize finishes, the resizeEnd event is called.\n * @memberof Moveable\n * @event resizeEnd\n * @param {Moveable.OnResizeEnd} - Parameters for the resizeEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n/**\n * When the scale starts, the scaleStart event is called.\n * @memberof Moveable\n * @event scaleStart\n * @param {Moveable.OnScaleStart} - Parameters for the scaleStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When scaling, the scale event is called.\n * @memberof Moveable\n * @event scale\n * @param {Moveable.OnScale} - Parameters for the scale event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the scale finishes, the scaleEnd event is called.\n * @memberof Moveable\n * @event scaleEnd\n * @param {Moveable.OnScaleEnd} - Parameters for the scaleEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n/**\n * When the rotate starts, the rotateStart event is called.\n * @memberof Moveable\n * @event rotateStart\n * @param {Moveable.OnRotateStart} - Parameters for the rotateStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When rotating, the rotate event is called.\n * @memberof Moveable\n * @event rotate\n * @param {Moveable.OnRotate} - Parameters for the rotate event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotate\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the rotate finishes, the rotateEnd event is called.\n * @memberof Moveable\n * @event rotateEnd\n * @param {Moveable.OnRotateEnd} - Parameters for the rotateEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the warp starts, the warpStart event is called.\n* @memberof Moveable\n* @event warpStart\n* @param {Moveable.OnWarpStart} - Parameters for the warpStart event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { warpable: true });\n* moveable.on(\"warpStart\", ({ target }) => {\n*     console.log(target);\n* });\n*/\n/**\n * When warping, the warp event is called.\n * @memberof Moveable\n * @event warp\n * @param {Moveable.OnWarp} - Parameters for the warp event\n * @example\n * import Moveable from \"moveable\";\n * let matrix = [\n *  1, 0, 0, 0,\n *  0, 1, 0, 0,\n *  0, 0, 1, 0,\n *  0, 0, 0, 1,\n * ];\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warp\", ({ target, transform, delta, multiply }) => {\n *    // target.style.transform = transform;\n *    matrix = multiply(matrix, delta);\n *    target.style.transform = `matrix3d(${matrix.join(\",\")})`;\n * });\n */\n/**\n * When the warp finishes, the warpEnd event is called.\n * @memberof Moveable\n * @event warpEnd\n * @param {Moveable.OnWarpEnd} - Parameters for the warpEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warpEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n/**\n * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart\n * @memberof Moveable\n * @event pinchStart\n * @param {Moveable.OnPinchStart} - Parameters for the pinchStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When pinching, the pinch event is called with part of scale, rotate, resize\n * @memberof Moveable\n * @event pinch\n * @param {Moveable.OnPinch} - Parameters for the pinch event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinch\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotate\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scale\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When the pinch finishes, the pinchEnd event is called.\n * @memberof Moveable\n * @event pinchEnd\n * @param {Moveable.OnPinchEnd} - Parameters for the pinchEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleEnd\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n /**\n * When the group resize starts, the `resizeGroupStart` event is called.\n * @memberof Moveable\n * @event resizeGroupStart\n * @param {Moveable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupStart\", ({ targets }) => {\n *     console.log(\"onResizeGroupStart\", targets);\n * });\n */\n\n /**\n * When the group resize, the `resizeGroup` event is called.\n * @memberof Moveable\n * @event resizeGroup\n * @param {Moveable.onResizeGroup} - Parameters for the `resizeGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroup\", ({ targets, events }) => {\n *     console.log(\"onResizeGroup\", targets);\n *     events.forEach(ev => {\n *         const offset = [\n *             direction[0] < 0 ? -ev.delta[0] : 0,\n *             direction[1] < 0 ? -ev.delta[1] : 0,\n *         ];\n *         // ev.drag is a drag event that occurs when the group resize.\n *         const left = offset[0] + ev.drag.beforeDist[0];\n *         const top = offset[1] + ev.drag.beforeDist[1];\n *         const width = ev.width;\n *         const top = ev.top;\n *     });\n * });\n */\n\n/**\n * When the group resize finishes, the `resizeGroupEnd` event is called.\n * @memberof Moveable\n * @event resizeGroupEnd\n * @param {Moveable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onResizeGroupEnd\", targets, isDrag);\n * });\n */\n\n /**\n * When the group scale starts, the `scaleGroupStart` event is called.\n * @memberof Moveable\n * @event scaleGroupStart\n * @param {Moveable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroupStart\", ({ targets }) => {\n *     console.log(\"onScaleGroupStart\", targets);\n * });\n */\n\n /**\n * When the group scale, the `scaleGroup` event is called.\n * @memberof Moveable\n * @event scaleGroup\n * @param {Moveable.OnScaleGroup} - Parameters for the `scaleGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroup\", ({ targets, events }) => {\n *     console.log(\"onScaleGroup\", targets);\n *     events.forEach(ev => {\n *         const target = ev.target;\n *         // ev.drag is a drag event that occurs when the group scale.\n *         const left = ev.drag.beforeDist[0];\n *         const top = ev.drag.beforeDist[1];\n *         const scaleX = ev.scale[0];\n *         const scaleY = ev.scale[1];\n *     });\n * });\n */\n\n/**\n * When the group scale finishes, the `scaleGroupEnd` event is called.\n * @memberof Moveable\n * @event scaleGroupEnd\n * @param {Moveable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onScaleGroupEnd\", targets, isDrag);\n * });\n */\n\n/**\n * When the group rotate starts, the `rotateGroupStart` event is called.\n * @memberof Moveable\n * @event rotateGroupStart\n * @param {Moveable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupStart\", ({ targets }) => {\n *     console.log(\"onRotateGroupStart\", targets);\n * });\n */\n\n /**\n * When the group rotate, the `rotateGroup` event is called.\n * @memberof Moveable\n * @event rotateGroup\n * @param {Moveable.OnRotateGroup} - Parameters for the `rotateGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroup\", ({ targets, events }) => {\n *     console.log(\"onRotateGroup\", targets);\n *     events.forEach(ev => {\n *         const target = ev.target;\n *         // ev.drag is a drag event that occurs when the group rotate.\n *         const left = ev.drag.beforeDist[0];\n *         const top = ev.drag.beforeDist[1];\n *         const deg = ev.beforeDist;\n *     });\n * });\n */\n\n/**\n * When the group rotate finishes, the `rotateGroupEnd` event is called.\n * @memberof Moveable\n * @event rotateGroupEnd\n * @param {Moveable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onRotateGroupEnd\", targets, isDrag);\n * });\n */\n\n/**\n * When the group pinch starts, the `pinchGroupStart` event is called.\n * @memberof Moveable\n * @event pinchGroupStart\n * @param {Moveable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupStart\", ({ targets }) => {\n *     console.log(\"onPinchGroupStart\", targets);\n * });\n */\n\n/**\n * When the group pinch, the `pinchGroup` event is called.\n * @memberof Moveable\n * @event pinchGroup\n * @param {Moveable.OnPinchGroup} - Parameters for the `pinchGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroup\", ({ targets, events }) => {\n *     console.log(\"onPinchGroup\", targets);\n * });\n */\n\n/**\n * When the group pinch finishes, the `pinchGroupEnd` event is called.\n * @memberof Moveable\n * @event pinchGroupEnd\n * @param {Moveable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onPinchGroupEnd\", targets, isDrag);\n * });\n */\n\n/**\n * When you click on the element, the `click` event is called.\n * @memberof Moveable\n * @event click\n * @param {Moveable.OnClick} - Parameters for the `click` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"click\", ({ hasTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", target, hasTarget, containsTarget, targetIndex);\n * });\n */\n\n/**\n * When you click on the element inside the group, the `clickGroup` event is called.\n * @memberof Moveable\n * @event clickGroup\n * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"clickGroup\", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", inputTarget, isTarget, containsTarget, targetIndex);\n * });\n */\n\n/**\n * `renderStart` event occurs at the first start of all events.\n * @memberof Moveable\n * @event renderStart\n * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderStart\", ({ target }) => {\n *     console.log(\"onRenderStart\", target);\n * });\n */\n\n/**\n * `render` event occurs before the target is drawn on the screen.\n * @memberof Moveable\n * @event render\n * @param {Moveable.OnRender} - Parameters for the `render` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"render\", ({ target }) => {\n *     console.log(\"onRender\", target);\n * });\n */\n\n/**\n * `renderEnd` event occurs at the end of all events.\n * @memberof Moveable\n * @event renderEnd\n * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderEnd\", ({ target }) => {\n *     console.log(\"onRenderEnd\", target);\n * });\n */\n\n/**\n * `renderGroupStart` event occurs at the first start of all events in group.\n * @memberof Moveable\n * @event renderGroupStart\n * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupStart\", ({ targets }) => {\n *     console.log(\"onRenderGroupStart\", targets);\n * });\n */\n\n/**\n * `renderGroup` event occurs before the target is drawn on the screen in group.\n * @memberof Moveable\n * @event renderGroup\n * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroup\", ({ targets }) => {\n *     console.log(\"onRenderGroup\", targets);\n * });\n */\n\n/**\n * `renderGroupEnd` event occurs at the end of all events in group.\n * @memberof Moveable\n * @event renderGroupEnd\n * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupEnd\", ({ targets }) => {\n *     console.log(\"onRenderGroupEnd\", targets);\n * });\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.\n * @memberof Moveable\n * @event scroll\n * @param {Moveable.OnScroll} - Parameters for the `scroll` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.\n * @memberof Moveable\n * @event scrollGroup\n * @param {Moveable.OnScrollGroup} - Parameters for the `scrollGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n\ninterface Moveable extends MoveableGetterSetter {\n    on(eventName: \"drag\", handlerToAttach: (event: OnDrag) => any): this;\n    on(eventName: \"dragStart\", handlerToAttach: (event: OnDragStart) => any): this;\n    on(eventName: \"dragEnd\", handlerToAttach: (event: OnDragEnd) => any): this;\n    on(eventName: \"dragGroup\", handlerToAttach: (event: OnDragGroup) => any): this;\n    on(eventName: \"dragGroupStart\", handlerToAttach: (event: OnDragGroupStart) => any): this;\n    on(eventName: \"dragGroupEnd\", handlerToAttach: (event: OnDragGroupEnd) => any): this;\n\n    on(eventName: \"resize\", handlerToAttach: (event: OnResize) => any): this;\n    on(eventName: \"resizeStart\", handlerToAttach: (event: OnResizeStart) => any): this;\n    on(eventName: \"resizeEnd\", handlerToAttach: (event: OnResizeEnd) => any): this;\n    on(eventName: \"resizeGroup\", handlerToAttach: (event: OnResizeGroup) => any): this;\n    on(eventName: \"resizeGroupStart\", handlerToAttach: (event: OnResizeGroupStart) => any): this;\n    on(eventName: \"resizeGroupEnd\", handlerToAttach: (event: OnResizeGroupEnd) => any): this;\n\n    on(eventName: \"scale\", handlerToAttach: (event: OnScale) => any): this;\n    on(eventName: \"scaleStart\", handlerToAttach: (event: OnScaleStart) => any): this;\n    on(eventName: \"scaleEnd\", handlerToAttach: (event: OnScaleEnd) => any): this;\n    on(eventName: \"scaleGroup\", handlerToAttach: (event: OnScaleGroup) => any): this;\n    on(eventName: \"scaleGroupStart\", handlerToAttach: (event: OnScaleGroupStart) => any): this;\n    on(eventName: \"scaleGroupEnd\", handlerToAttach: (event: OnScaleGroupEnd) => any): this;\n\n    on(eventName: \"rotate\", handlerToAttach: (event: OnRotate) => any): this;\n    on(eventName: \"rotateStart\", handlerToAttach: (event: OnRotateStart) => any): this;\n    on(eventName: \"rotateEnd\", handlerToAttach: (event: OnRotateEnd) => any): this;\n    on(eventName: \"rotateGroup\", handlerToAttach: (event: OnRotateGroup) => any): this;\n    on(eventName: \"rotateGroupStart\", handlerToAttach: (event: OnRotateGroupStart) => any): this;\n    on(eventName: \"rotateGroupEnd\", handlerToAttach: (event: OnRotateGroupEnd) => any): this;\n\n    on(eventName: \"warp\", handlerToAttach: (event: OnWarp) => any): this;\n    on(eventName: \"warpStart\", handlerToAttach: (event: OnWarpStart) => any): this;\n    on(eventName: \"warpEnd\", handlerToAttach: (event: OnWarpEnd) => any): this;\n\n    on(eventName: \"pinch\", handlerToAttach: (event: OnPinch) => any): this;\n    on(eventName: \"pinchStart\", handlerToAttach: (event: OnPinchStart) => any): this;\n    on(eventName: \"pinchEnd\", handlerToAttach: (event: OnPinchEnd) => any): this;\n    on(eventName: \"pinchGroup\", handlerToAttach: (event: OnPinchGroup) => any): this;\n    on(eventName: \"pinchGroupStart\", handlerToAttach: (event: OnPinchGroupStart) => any): this;\n    on(eventName: \"pinchGroupEnd\", handlerToAttach: (event: OnPinchGroupEnd) => any): this;\n\n    on(eventName: \"click\", handlerToAttach: (event: OnClick) => any): this;\n    on(eventName: \"clickGroup\", handlerToAttach: (event: OnClickGroup) => any): this;\n\n    on(eventName: \"scroll\", handlerToAttach: (event: OnScroll) => any): this;\n    on(eventName: \"scrollGroup\", handlerToAttach: (event: OnScrollGroup) => any): this;\n\n    on(eventName: \"renderStart\", handlerToAttach: (event: OnRenderStart) => any): this;\n    on(eventName: \"render\", handlerToAttach: (event: OnRender) => any): this;\n    on(eventName: \"renderEnd\", handlerToAttach: (event: OnRenderEnd) => any): this;\n    on(eventName: \"renderGroupStart\", handlerToAttach: (event: OnRenderGroupStart) => any): this;\n    on(eventName: \"renderGroup\", handlerToAttach: (event: OnRenderGroup) => any): this;\n    on(eventName: \"renderGroupEnd\", handlerToAttach: (event: OnRenderGroupEnd) => any): this;\n\n    on(eventName: string, handlerToAttach: (event: { [key: string]: any }) => any): this;\n    on(events: { [key: string]: (event: { [key: string]: any }) => any }): this;\n}\n\nexport default Moveable;\n"],"names":["__extends","props","_super","_this","state","createPortal","h","Moveable","ref","parentElement","Component","PROPERTIES","EVENTS","options","document","createElement","nextOptions","container","events","forEach","name","camelize","e","trigger","render","InnerMoveable","tempElement","target","isArray","length","updateRect","getMoveable","isMoveableElement","dragStart","clientX","clientY","isInside","getRect","callback","innerMoveable","setState","updateTarget","off","preactMoveable","Properties","prototype","property","Object","defineProperty","get","set","value","_a","enumerable","configurable","EgComponent"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;;;EAA2CA,gCAAA;;wBAGvC,CAAYC,KAAZ;gBACIC,WAAA,KAAA,EAAMD,KAAN,SADJ;;IAFOE,WAAA,GAAuB,EAAvB;IAIHA,KAAI,CAACC,KAAL,GAAaD,KAAI,CAACF,KAAlB;;;;;;gBAEG,GAAP;WACWI,YAAY,CAACC,EAACC;MAASC,GAAG,EAAEA,GAAG,CAAC,IAAD,EAAO,gBAAP;OAA8B,KAAKJ,OAAtD,EAAiE,KAAKA,KAAL,CAAWK,aAA5E,CAAnB;GADG;;sBAGX;EAV2CC,UAA3C;;ICHaC,UAAU,GAAiC,CACpD,WADoD,EACvC,WADuC,EAC1B,UAD0B,EACd,WADc,EAEpD,UAFoD,EAExC,WAFwC,EAE3B,WAF2B,EAEd,QAFc,EAEJ,QAFI,EAEM,MAFN,EAGpD,cAHoD,EAGpC,gBAHoC,EAIpD,eAJoD,EAInC,gBAJmC,EAIjB,WAJiB,EAKpD,UALoD,EAMpD,gBANoD,EAOpD,YAPoD,EAOtC,eAPsC,EAQpD,sBARoD,EAQ5B,oBAR4B,EAQN,mBARM,EASpD,QAToD,EAWpD,WAXoD,EAYpD,kBAZoD,EAapD,YAboD,EAcpD,mBAdoD,EAepD,iBAfoD,EAgBpD,iBAhBoD,EAiBpD,eAjBoD,CAAjD;AAmBP,IAAaC,MAAM,GAAgC,CAC/C,WAD+C,EAE/C,MAF+C,EAG/C,SAH+C,EAI/C,aAJ+C,EAK/C,QAL+C,EAM/C,WAN+C,EAO/C,YAP+C,EAQ/C,OAR+C,EAS/C,UAT+C,EAU/C,aAV+C,EAW/C,QAX+C,EAY/C,WAZ+C,EAa/C,WAb+C,EAc/C,MAd+C,EAe/C,SAf+C,EAgB/C,YAhB+C,EAiB/C,OAjB+C,EAkB/C,UAlB+C,EAmB/C,gBAnB+C,EAoB/C,WApB+C,EAqB/C,cArB+C,EAsB/C,kBAtB+C,EAuB/C,aAvB+C,EAwB/C,gBAxB+C,EAyB/C,iBAzB+C,EA0B/C,YA1B+C,EA2B/C,eA3B+C,EA4B/C,kBA5B+C,EA6B/C,aA7B+C,EA8B/C,gBA9B+C,EA+B/C,iBA/B+C,EAgC/C,YAhC+C,EAiC/C,eAjC+C,EAkC/C,YAlC+C,EAoC/C,QApC+C,EAqC/C,aArC+C,EAuC/C,aAvC+C,EAwC/C,QAxC+C,EAyC/C,WAzC+C,EA0C/C,kBA1C+C,EA2C/C,aA3C+C,EA4C/C,gBA5C+C,CAA5C;;ACSP;;;;;;AAmBA;;;EAAuBZ,2BAAA;;;;;;mBAOnB,CAAYS,aAAZ,EAAqDI,OAArD;0BAAqD,EAAA;MAAAA,YAAA;;;gBACjDX,WAAA,KAAA,SADJ;;IALQC,iBAAA,GAAcW,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAd;;QAOEC,WAAW;MAAKC,SAAS,EAAER;OAAkBI,QAAnD;;QAEMK,MAAM,GAAQ,EAApB;IAEAN,MAAM,CAACO,OAAP,CAAe,UAAAC,IAAA;MACXF,MAAM,CAACG,QAAQ,CAAC,QAAMD,IAAP,CAAT,CAAN,GAAiC,UAACE,CAAD;eAAYnB,KAAI,CAACoB,OAAL,CAAaH,IAAb,EAAmBE,CAAnB,CAAA;OAA7C;KADJ;IAIAE,MAAM,CACFlB,EAACmB;MACGjB,GAAG,EAAEA,GAAG,CAACL,KAAD,EAAO,eAAP;MACRM,aAAa,EAAEA;OACXO,aACAE,QALN,EAOFf,KAAI,CAACuB,WAPH,CAAN;QASMC,MAAM,GAAGX,WAAW,CAACW,MAA3B;;QACIC,OAAO,CAACD,MAAD,CAAP,IAAmBA,MAAM,CAACE,MAAP,GAAgB,CAAvC,EAA0C;MACtC1B,KAAI,CAAC2B,UAAL;;;;;;;;;;;;;;;;;;;;;;;2BAiBD,GAAP,UAAyBH,MAAzB;WACW,KAAKI,WAAL,GAAmBC,iBAAnB,CAAqCL,MAArC,CAAP;GADG;;;;;;;;;;;;;;oBAcA,GAAP;SACSI,WAAL,GAAmBD,UAAnB;GADG;;;;;;;;;;;;;;;;;mBAiBA,GAAP,UAAiBR,CAAjB;SACSS,WAAL,GAAmBE,SAAnB,CAA6BX,CAA7B;GADG;;;;;;;;;;;;;;;;;;;kBAoBA,GAAP,UAAgBY,OAAhB,EAAiCC,OAAjC;WACW,KAAKJ,WAAL,GAAmBK,QAAnB,CAA4BF,OAA5B,EAAqCC,OAArC,CAAP;GADG;;;;;;;;;;;;;iBAaA,GAAP;WACW,KAAKJ,WAAL,GAAmBM,OAAnB,EAAP;GADG;;;;;;;;;;;;;;;;;;kBAkBA,GAAP,UAAgBjC,KAAhB,EAAiDkC,QAAjD;SACSC,aAAL,CAAmBC,QAAnB,CAA4BpC,KAA5B,EAAmCkC,QAAnC;GADG;;;;;;;;;;;;;sBAaA,GAAP;SACSP,WAAL,GAAmBU,YAAnB;GADG;;;;;;;;;;;;iBAYA,GAAP;IACIjB,MAAM,CAAC,EAAD,EAAK,KAAKE,WAAV,CAAN;SACKgB,GAAL;SACKhB,WAAL,GAAmB,IAAnB;SACKa,aAAL,GAAqB,IAArB;GAJG;;qBAMC,GAAR;WACW,KAAKA,aAAL,CAAmBI,cAA1B;GADI;;EA9JNpC,QAAQ,eAdbqC,UAAU,CAACjC,UAAD,EAAa,UAACkC,SAAD,EAAYC,QAAZ;IACpBC,MAAM,CAACC,cAAP,CAAsBH,SAAtB,EAAiCC,QAAjC,EAA2C;MACvCG,GAAG;eACQ,KAAKlB,WAAL,GAAmB9B,KAAnB,CAAyB6C,QAAzB,CAAP;OAFmC;MAIvCI,GAAG,YAACC;;;aACKX,QAAL,WACIY,GAACN,SAAD,GAAYK,SADhB;OALmC;MASvCE,UAAU,EAAE,IAT2B;MAUvCC,YAAY,EAAE;KAVlB;GADO,IAcL/C,SAAA;iBAiKN;EAjKuBgD,YAAvB;;;;;"}